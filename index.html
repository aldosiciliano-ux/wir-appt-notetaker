<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">
  <title>WIR Appointment Notetaker</title>
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <style>
    :root {
      --wir-blue-light: #5BC4F1;
      --wir-blue-mid: #3AA4DA;
      --wir-blue-dark: #1E5F99;
      --wir-green: #A4D233;
      --wir-black: #000000;
      --wir-white: #FFFFFF;
      --gradient-wir: linear-gradient(135deg, var(--wir-blue-light) 0%, var(--wir-blue-dark) 50%, var(--wir-green) 100%);
      --gradient-blue: linear-gradient(135deg, var(--wir-blue-light) 0%, var(--wir-blue-dark) 100%);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--wir-black);
      min-height: 100vh;
      color: var(--wir-white);
    }

    .container {
      max-width: 480px;
      margin: 0 auto;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      text-align: center;
      padding: 20px 0;
    }

    .header h1 {
      font-size: 22px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .header p {
      font-size: 14px;
      opacity: 0.7;
    }

    .logo {
      height: 50px;
      margin: 0 auto 20px;
      display: block;
    }

    .logo-icon {
      width: 70px;
      height: 70px;
      margin: 0 auto 16px;
      display: block;
    }

    /* Cards */
    .card {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .card-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      color: var(--wir-white);
    }

    /* Form Elements */
    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 8px;
      opacity: 0.9;
    }

    .form-input {
      width: 100%;
      padding: 14px 16px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      color: var(--wir-white);
      font-size: 16px;
      outline: none;
      transition: all 0.2s;
    }

    .form-input:focus {
      border-color: var(--wir-blue-light);
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 0 3px rgba(91, 196, 241, 0.2);
    }

    .form-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    select.form-input {
      cursor: pointer;
    }

    select.form-input option {
      background: var(--wir-black);
      color: var(--wir-white);
    }

    /* Buttons */
    .btn {
      width: 100%;
      padding: 16px 24px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn-primary {
      background: var(--gradient-blue);
      color: var(--wir-white);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(91, 196, 241, 0.3);
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: var(--wir-white);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .btn-success {
      background: linear-gradient(135deg, var(--wir-green) 0%, #8BC02A 100%);
      color: var(--wir-black);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: var(--wir-white);
    }

    /* Appointment Type Buttons */
    .type-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .type-btn {
      padding: 16px;
      background: rgba(255, 255, 255, 0.08);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      color: var(--wir-white);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .type-btn:hover {
      background: rgba(91, 196, 241, 0.1);
      border-color: rgba(91, 196, 241, 0.3);
    }

    .type-btn.selected {
      background: rgba(91, 196, 241, 0.2);
      border-color: var(--wir-blue-light);
      color: var(--wir-blue-light);
    }

    /* Recording Screen */
    .recording-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
    }

    .recording-status {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .recording-dot {
      width: 12px;
      height: 12px;
      background: #ef4444;
      border-radius: 50%;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .recording-dot.paused {
      background: var(--wir-green);
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    .timer {
      font-size: 64px;
      font-weight: 300;
      font-variant-numeric: tabular-nums;
      margin-bottom: 40px;
      background: var(--gradient-wir);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .waveform {
      width: 100%;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      margin-bottom: 40px;
    }

    .wave-bar {
      width: 4px;
      background: var(--gradient-blue);
      border-radius: 2px;
      transition: height 0.1s;
    }

    .recording-info {
      text-align: center;
      margin-bottom: 40px;
      opacity: 0.8;
    }

    .recording-info p {
      font-size: 14px;
      margin-bottom: 4px;
    }

    .recording-info strong {
      color: var(--wir-blue-light);
    }

    .recording-controls {
      display: flex;
      gap: 20px;
      align-items: center;
    }

    .record-btn {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .record-btn.pause {
      background: var(--gradient-blue);
    }

    .record-btn.resume {
      background: linear-gradient(135deg, var(--wir-green) 0%, #8BC02A 100%);
    }

    .record-btn:hover {
      transform: scale(1.08);
      box-shadow: 0 8px 25px rgba(91, 196, 241, 0.4);
    }

    .record-btn svg {
      width: 32px;
      height: 32px;
      fill: var(--wir-white);
    }

    .record-btn.resume svg {
      fill: var(--wir-black);
    }

    .finish-btn {
      padding: 16px 32px;
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      border: none;
      border-radius: 40px;
      color: var(--wir-white);
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .finish-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
    }

    /* Warning Banner */
    .warning-banner {
      background: rgba(164, 210, 51, 0.15);
      border: 1px solid rgba(164, 210, 51, 0.4);
      border-radius: 12px;
      padding: 12px 16px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 14px;
    }

    .warning-banner svg {
      width: 24px;
      height: 24px;
      fill: var(--wir-green);
      flex-shrink: 0;
    }

    /* Confirmation Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 100;
    }

    .modal {
      background: #111;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 28px;
      max-width: 360px;
      width: 100%;
      text-align: center;
    }

    .modal h3 {
      font-size: 20px;
      margin-bottom: 12px;
    }

    .modal p {
      font-size: 14px;
      opacity: 0.8;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
    }

    .modal-buttons .btn {
      flex: 1;
    }

    /* Success Screen */
    .success-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 20px;
    }

    .success-icon {
      width: 100px;
      height: 100px;
      background: linear-gradient(135deg, var(--wir-green) 0%, #8BC02A 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 24px;
      box-shadow: 0 10px 40px rgba(164, 210, 51, 0.3);
    }

    .success-icon svg {
      width: 50px;
      height: 50px;
      fill: var(--wir-black);
    }

    .success-screen h2 {
      font-size: 28px;
      margin-bottom: 12px;
    }

    .success-screen p {
      font-size: 16px;
      opacity: 0.8;
      margin-bottom: 32px;
      line-height: 1.6;
    }

    /* Loading Spinner */
    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid rgba(255, 255, 255, 0.2);
      border-top-color: var(--wir-blue-light);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* User Badge */
    .user-badge {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.08);
      padding: 12px 16px;
      border-radius: 12px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .user-avatar {
      width: 44px;
      height: 44px;
      background: var(--gradient-blue);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 18px;
    }

    .user-info {
      flex: 1;
    }

    .user-name {
      font-weight: 600;
      font-size: 15px;
    }

    .user-email {
      font-size: 13px;
      opacity: 0.6;
    }

    .logout-btn {
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      cursor: pointer;
      padding: 8px;
      transition: color 0.2s;
    }

    .logout-btn:hover {
      color: var(--wir-white);
    }

    /* Hide screens by default */
    .screen {
      display: none;
      flex-direction: column;
      flex: 1;
    }

    .screen.active {
      display: flex;
    }

    /* Accent text */
    .text-accent {
      color: var(--wir-blue-light);
    }

    .text-green {
      color: var(--wir-green);
    }

    /* Divider */
    .divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 20px 0;
    }

    /* ============================================ */
    /* Offline / Queue Styles                       */
    /* ============================================ */

    .offline-banner {
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid rgba(239, 68, 68, 0.4);
      border-radius: 12px;
      padding: 10px 16px;
      margin-bottom: 16px;
      display: none;
      align-items: center;
      gap: 10px;
      font-size: 13px;
      font-weight: 500;
      color: #fca5a5;
    }

    .offline-banner.visible {
      display: flex;
    }

    .offline-dot {
      width: 8px;
      height: 8px;
      background: #ef4444;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .queue-banner {
      background: rgba(251, 191, 36, 0.15);
      border: 1px solid rgba(251, 191, 36, 0.4);
      border-radius: 12px;
      padding: 12px 16px;
      margin-bottom: 16px;
      display: none;
      align-items: center;
      gap: 10px;
      font-size: 13px;
      color: #fde68a;
    }

    .queue-banner.visible {
      display: flex;
    }

    .queue-banner-text {
      flex: 1;
    }

    .queue-retry-btn {
      background: rgba(251, 191, 36, 0.3);
      border: 1px solid rgba(251, 191, 36, 0.5);
      border-radius: 8px;
      color: #fde68a;
      font-size: 12px;
      font-weight: 600;
      padding: 6px 12px;
      cursor: pointer;
      white-space: nowrap;
      transition: all 0.2s;
    }

    .queue-retry-btn:hover {
      background: rgba(251, 191, 36, 0.5);
    }

    .queue-retry-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .saved-offline-icon {
      width: 100px;
      height: 100px;
      background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 24px;
      box-shadow: 0 10px 40px rgba(251, 191, 36, 0.3);
    }

    .saved-offline-icon svg {
      width: 50px;
      height: 50px;
      fill: var(--wir-black);
    }

    /* Responsive */
    @media (max-width: 380px) {
      .timer {
        font-size: 48px;
      }
      
      .type-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    
    <!-- Offline Banner (persistent, shown on any screen when offline) -->
    <div id="offlineBanner" class="offline-banner">
      <div class="offline-dot"></div>
      <span>No internet connection — recordings will be saved locally</span>
    </div>

    <!-- Queue Banner (shown when there are pending uploads) -->
    <div id="queueBanner" class="queue-banner">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" style="flex-shrink:0;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
      <span class="queue-banner-text" id="queueBannerText">1 recording waiting to upload</span>
      <button class="queue-retry-btn" id="queueRetryBtn" onclick="retryQueuedUploads()">Retry</button>
    </div>

    <!-- Login Screen -->
    <div id="loginScreen" class="screen active">
      <div class="header" style="padding-top: 60px;">
        <img src="WIR LOGO.png" alt="WIR Logo" style="width: 220px; margin: 0 auto 20px; display: block;">
        <h1>Appointment Notetaker</h1>
        <p>Transcribe your listing appointments</p>
      </div>
      
      <div class="card" style="margin-top: 20px;">
        <div class="card-title">Sign In</div>
        
        <div class="form-group">
          <label class="form-label">Email Address</label>
          <input type="email" id="loginEmail" class="form-input" placeholder="you@wattersinternational.com">
        </div>
        
        <div class="form-group">
          <label class="form-label">Password</label>
          <input type="password" id="loginPassword" class="form-input" placeholder="Enter password">
        </div>
        
        <button id="loginBtn" class="btn btn-primary">Sign In</button>
        
        <p id="loginError" style="color: #ef4444; font-size: 14px; margin-top: 12px; text-align: center; display: none;"></p>
      </div>
      
      <p style="text-align: center; font-size: 12px; opacity: 0.4; margin-top: auto; padding: 20px;">
        Watters International Realty
      </p>
    </div>

    <!-- Setup Screen -->
    <div id="setupScreen" class="screen">
      <div class="header">
        <h1>New Recording</h1>
        <p>Enter appointment details</p>
      </div>
      
      <div class="user-badge">
        <div class="user-avatar" id="userAvatar">A</div>
        <div class="user-info">
          <div class="user-name" id="userName">Agent Name</div>
          <div class="user-email" id="userEmailDisplay">agent@example.com</div>
        </div>
        <button class="logout-btn" id="logoutBtn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
            <polyline points="16 17 21 12 16 7"></polyline>
            <line x1="21" y1="12" x2="9" y2="12"></line>
          </svg>
        </button>
      </div>
      
      <div class="card">
        <div class="form-group">
          <label class="form-label">Client Name <span class="text-accent">*</span></label>
          <input type="text" id="clientName" class="form-input" placeholder="Enter client name">
        </div>
        
        <div class="form-group">
          <label class="form-label">Appointment Type <span class="text-accent">*</span></label>
          <div class="type-grid">
            <button class="type-btn" data-type="Listing Appointment">Listing Appointment</button>
            <button class="type-btn" data-type="Buyer Consultation">Buyer Consultation</button>
            <button class="type-btn" data-type="Follow-up">Follow-up</button>
            <button class="type-btn" data-type="Other">Other</button>
          </div>
        </div>
        
        <div class="form-group">
          <label class="form-label">Transaction Coordinator <span class="text-accent">*</span></label>
          <select id="tcSelect" class="form-input">
            <option value="">Select TC...</option>
          </select>
        </div>
        
        <div class="form-group">
          <label class="form-label">Notes <span style="opacity: 0.5;">(optional)</span></label>
          <input type="text" id="notes" class="form-input" placeholder="Any additional notes">
        </div>
        
        <button id="startRecordingBtn" class="btn btn-primary" disabled>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="12" r="8"/></svg>
          Start Recording
        </button>
      </div>
    </div>

    <!-- Recording Screen -->
    <div id="recordingScreen" class="screen">
      <div class="recording-screen">
        <div class="recording-status">
          <div class="recording-dot" id="recordingDot"></div>
          <span id="recordingStatusText">Recording</span>
        </div>
        
        <div class="timer" id="timer">00:00:00</div>
        
        <div class="waveform" id="waveform"></div>
        
        <div class="recording-info">
          <p><strong id="recordingClient">Client Name</strong></p>
          <p id="recordingType">Listing Appointment</p>
        </div>
        
        <div id="shortRecordingWarning" class="warning-banner" style="display: none;">
          <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
          <span>Recording is under 15 minutes. Are you sure the appointment is complete?</span>
        </div>
        
        <div class="recording-controls">
          <button class="record-btn pause" id="pauseResumeBtn">
            <svg id="pauseIcon" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            <svg id="playIcon" viewBox="0 0 24 24" style="display: none;"><path d="M8 5v14l11-7z"/></svg>
          </button>
          
          <button class="finish-btn" id="finishBtn">Finish Recording</button>
        </div>
      </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmModal" class="modal-overlay" style="display: none;">
      <div class="modal">
        <h3 id="modalTitle">Finish Recording?</h3>
        <p id="modalMessage">Your recording will be processed and you'll receive the transcript via email within 15 minutes.</p>
        <div class="modal-buttons">
          <button class="btn btn-secondary" id="modalCancel">Keep Recording</button>
          <button class="btn btn-primary" id="modalConfirm">Finish</button>
        </div>
      </div>
    </div>

    <!-- Uploading Screen -->
    <div id="uploadingScreen" class="screen">
      <div class="success-screen">
        <div class="spinner" style="width: 60px; height: 60px; border-width: 4px; margin-bottom: 24px;"></div>
        <h2 id="uploadingTitle">Uploading...</h2>
        <p id="uploadingMessage">Please wait while we upload your recording.</p>
      </div>
    </div>

    <!-- Success Screen -->
    <div id="successScreen" class="screen">
      <div class="success-screen">
        <div class="success-icon">
          <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
        </div>
        <h2>Recording Submitted!</h2>
        <p>Your appointment recording is being processed. You'll receive the transcript and notes via email within <span class="text-green">15 minutes</span>.</p>
        <button id="newRecordingBtn" class="btn btn-success">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
          Start New Recording
        </button>
      </div>
    </div>

    <!-- Saved Offline Screen -->
    <div id="savedOfflineScreen" class="screen">
      <div class="success-screen">
        <div class="saved-offline-icon">
          <svg viewBox="0 0 24 24"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4c-1.48 0-2.85.43-4.01 1.17l1.46 1.46C10.21 6.23 11.08 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3 0 1.13-.64 2.11-1.56 2.62l1.45 1.45C23.16 18.16 24 16.68 24 15c0-2.64-2.05-4.78-4.65-4.96zM3 5.27l2.75 2.74C2.56 8.15 0 10.77 0 14c0 3.31 2.69 6 6 6h11.73l2 2 1.27-1.27L4.27 4 3 5.27zM7.73 10l8 8H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h1.73z"/></svg>
        </div>
        <h2>Saved Locally</h2>
        <p>No internet connection. Your recording has been saved to this device and will upload automatically when you're back online.</p>
        <p style="font-size: 13px; opacity: 0.6; margin-bottom: 24px;">Keep your browser open or come back to this page later.</p>
        <button id="newRecordingOfflineBtn" class="btn btn-success">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
          Start New Recording
        </button>
      </div>
    </div>

  </div>

  <script>
    // ============================================
    // Configuration
    // ============================================
    
    const CONFIG = {
      appsScriptUrl: 'https://script.google.com/macros/s/AKfycbzNbvlZCTMCPKYbPQJ5pvgS66iKN8naDqG09ATA7EmNHzmPBTaKLmWQ4SGYC13GdPP4Pw/exec',
      password: '#ONESTEPAHEAD2026',
      teamMembers: [
        { name: 'Tanya Wohleb', email: 'tanya.wohleb@wattersinternational.com' },
        { name: 'Debbie Lopez', email: 'debbie.lopez@wattersinternational.com' },
        { name: 'Tracy Hykel', email: 'tracy.hykel@wattersinternational.com' },
        { name: 'Jodi Raughton', email: 'jodi.raughton@wattersinternational.com' }
      ],
      dbName: 'WIR_RecorderDB',
      dbVersion: 1,
      storeName: 'pendingUploads'
    };

    // ============================================
    // State
    // ============================================
    
    let state = {
      user: null,
      clientName: '',
      appointmentType: '',
      selectedTC: null,
      notes: '',
      isRecording: false,
      isPaused: false,
      recordingStartTime: null,
      elapsedTime: 0,
      pausedTime: 0,
      pauseStartTime: null,
      mediaRecorder: null,
      audioChunks: [],
      timerInterval: null,
      waveformInterval: null,
      audioContext: null,
      analyser: null,
      wakeLock: null,
      isOnline: navigator.onLine,
      isUploading: false,
      db: null
    };

    // ============================================
    // DOM Elements
    // ============================================
    
    const screens = {
      login: document.getElementById('loginScreen'),
      setup: document.getElementById('setupScreen'),
      recording: document.getElementById('recordingScreen'),
      uploading: document.getElementById('uploadingScreen'),
      success: document.getElementById('successScreen'),
      savedOffline: document.getElementById('savedOfflineScreen')
    };

    const elements = {
      loginEmail: document.getElementById('loginEmail'),
      loginPassword: document.getElementById('loginPassword'),
      loginBtn: document.getElementById('loginBtn'),
      loginError: document.getElementById('loginError'),
      userAvatar: document.getElementById('userAvatar'),
      userName: document.getElementById('userName'),
      userEmailDisplay: document.getElementById('userEmailDisplay'),
      logoutBtn: document.getElementById('logoutBtn'),
      clientName: document.getElementById('clientName'),
      tcSelect: document.getElementById('tcSelect'),
      notes: document.getElementById('notes'),
      startRecordingBtn: document.getElementById('startRecordingBtn'),
      timer: document.getElementById('timer'),
      waveform: document.getElementById('waveform'),
      recordingDot: document.getElementById('recordingDot'),
      recordingStatusText: document.getElementById('recordingStatusText'),
      recordingClient: document.getElementById('recordingClient'),
      recordingType: document.getElementById('recordingType'),
      pauseResumeBtn: document.getElementById('pauseResumeBtn'),
      pauseIcon: document.getElementById('pauseIcon'),
      playIcon: document.getElementById('playIcon'),
      finishBtn: document.getElementById('finishBtn'),
      shortRecordingWarning: document.getElementById('shortRecordingWarning'),
      confirmModal: document.getElementById('confirmModal'),
      modalTitle: document.getElementById('modalTitle'),
      modalMessage: document.getElementById('modalMessage'),
      modalCancel: document.getElementById('modalCancel'),
      modalConfirm: document.getElementById('modalConfirm'),
      newRecordingBtn: document.getElementById('newRecordingBtn'),
      newRecordingOfflineBtn: document.getElementById('newRecordingOfflineBtn'),
      offlineBanner: document.getElementById('offlineBanner'),
      queueBanner: document.getElementById('queueBanner'),
      queueBannerText: document.getElementById('queueBannerText'),
      queueRetryBtn: document.getElementById('queueRetryBtn'),
      uploadingTitle: document.getElementById('uploadingTitle'),
      uploadingMessage: document.getElementById('uploadingMessage')
    };

    // ============================================
    // IndexedDB — Offline Storage
    // ============================================

    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(CONFIG.dbName, CONFIG.dbVersion);
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(CONFIG.storeName)) {
            const store = db.createObjectStore(CONFIG.storeName, { keyPath: 'id', autoIncrement: true });
            store.createIndex('createdAt', 'createdAt', { unique: false });
          }
        };

        request.onsuccess = (event) => {
          state.db = event.target.result;
          resolve(state.db);
        };

        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.error);
          reject(event.target.error);
        };
      });
    }

    async function saveToQueue(payload, audioBlob) {
      const db = state.db || await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(CONFIG.storeName, 'readwrite');
        const store = tx.objectStore(CONFIG.storeName);
        
        const record = {
          payload: payload,
          audioBlob: audioBlob,
          createdAt: new Date().toISOString(),
          retries: 0
        };

        const request = store.add(record);
        request.onsuccess = () => {
          console.log('Recording saved to offline queue, id:', request.result);
          resolve(request.result);
        };
        request.onerror = () => reject(request.error);
      });
    }

    async function getQueuedRecordings() {
      const db = state.db || await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(CONFIG.storeName, 'readonly');
        const store = tx.objectStore(CONFIG.storeName);
        const request = store.getAll();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function removeFromQueue(id) {
      const db = state.db || await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(CONFIG.storeName, 'readwrite');
        const store = tx.objectStore(CONFIG.storeName);
        const request = store.delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    async function getQueueCount() {
      const db = state.db || await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(CONFIG.storeName, 'readonly');
        const store = tx.objectStore(CONFIG.storeName);
        const request = store.count();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // ============================================
    // Online / Offline Detection
    // ============================================

    function updateOnlineStatus() {
      state.isOnline = navigator.onLine;
      
      if (state.isOnline) {
        elements.offlineBanner.classList.remove('visible');
        // Auto-retry queued uploads when back online
        retryQueuedUploads();
      } else {
        elements.offlineBanner.classList.add('visible');
      }
    }

    async function updateQueueBanner() {
      try {
        const count = await getQueueCount();
        if (count > 0) {
          elements.queueBannerText.textContent = 
            count === 1 
              ? '1 recording waiting to upload' 
              : `${count} recordings waiting to upload`;
          elements.queueBanner.classList.add('visible');
        } else {
          elements.queueBanner.classList.remove('visible');
        }
      } catch (e) {
        console.error('Error checking queue:', e);
      }
    }

    async function retryQueuedUploads() {
      if (state.isUploading || !navigator.onLine) return;
      
      state.isUploading = true;
      elements.queueRetryBtn.disabled = true;
      elements.queueRetryBtn.textContent = 'Uploading...';

      try {
        const recordings = await getQueuedRecordings();
        
        for (const record of recordings) {
          if (!navigator.onLine) break;
          
          try {
            const base64Audio = await blobToBase64(record.audioBlob);
            const fullPayload = { ...record.payload, audio: base64Audio.split(',')[1] };

            const response = await fetch(CONFIG.appsScriptUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'text/plain' },
              body: JSON.stringify(fullPayload)
            });

            await removeFromQueue(record.id);
            console.log('Queued recording uploaded successfully, id:', record.id);

          } catch (err) {
            console.warn('Failed to upload queued recording id:', record.id, err);
          }
        }
      } catch (e) {
        console.error('Error processing queue:', e);
      } finally {
        state.isUploading = false;
        elements.queueRetryBtn.disabled = false;
        elements.queueRetryBtn.textContent = 'Retry';
        updateQueueBanner();
      }
    }

    // ============================================
    // Screen Navigation
    // ============================================
    
    function showScreen(screenName) {
      Object.values(screens).forEach(s => s.classList.remove('active'));
      screens[screenName].classList.add('active');
    }

    // ============================================
    // Login
    // ============================================
    
    function checkStoredLogin() {
      const stored = localStorage.getItem('wirUser');
      if (stored) {
        state.user = JSON.parse(stored);
        updateUserDisplay();
        showScreen('setup');
      }
    }

    function login() {
      const email = elements.loginEmail.value.trim();
      const password = elements.loginPassword.value;

      if (!email) {
        showLoginError('Please enter your email');
        return;
      }

      if (password !== CONFIG.password) {
        showLoginError('Invalid password');
        return;
      }

      state.user = {
        email: email,
        name: email.split('@')[0].replace(/[._]/g, ' ').replace(/\b\w/g, c => c.toUpperCase())
      };

      localStorage.setItem('wirUser', JSON.stringify(state.user));
      updateUserDisplay();
      showScreen('setup');
    }

    function logout() {
      localStorage.removeItem('wirUser');
      state.user = null;
      elements.loginEmail.value = '';
      elements.loginPassword.value = '';
      showScreen('login');
    }

    function showLoginError(message) {
      elements.loginError.textContent = message;
      elements.loginError.style.display = 'block';
      setTimeout(() => {
        elements.loginError.style.display = 'none';
      }, 3000);
    }

    function updateUserDisplay() {
      if (state.user) {
        elements.userAvatar.textContent = state.user.name.charAt(0).toUpperCase();
        elements.userName.textContent = state.user.name;
        elements.userEmailDisplay.textContent = state.user.email;
      }
    }

    // ============================================
    // Setup Form
    // ============================================
    
    function populateTCDropdown() {
      CONFIG.teamMembers.forEach(tc => {
        const option = document.createElement('option');
        option.value = JSON.stringify(tc);
        option.textContent = tc.name;
        elements.tcSelect.appendChild(option);
      });
    }

    function selectAppointmentType(type) {
      state.appointmentType = type;
      document.querySelectorAll('.type-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.type === type);
      });
      validateForm();
    }

    function validateForm() {
      const isValid = 
        elements.clientName.value.trim() !== '' &&
        state.appointmentType !== '' &&
        elements.tcSelect.value !== '';
      
      elements.startRecordingBtn.disabled = !isValid;
    }

    // ============================================
    // Recording
    // ============================================
    
    async function startRecording() {
      // Request wake lock to prevent screen from turning off
      if ('wakeLock' in navigator) {
        try {
          state.wakeLock = await navigator.wakeLock.request('screen');
          console.log('Wake lock active');
        } catch (err) {
          console.log('Wake lock failed:', err);
        }
      }

      state.clientName = elements.clientName.value.trim();
      state.selectedTC = JSON.parse(elements.tcSelect.value);
      state.notes = elements.notes.value.trim();

      // Update recording screen info
      elements.recordingClient.textContent = state.clientName;
      elements.recordingType.textContent = state.appointmentType;

      // Initialize waveform bars
      elements.waveform.innerHTML = '';
      for (let i = 0; i < 40; i++) {
        const bar = document.createElement('div');
        bar.className = 'wave-bar';
        bar.style.height = '10px';
        elements.waveform.appendChild(bar);
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Set up audio analysis for waveform
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        state.analyser = state.audioContext.createAnalyser();
        const source = state.audioContext.createMediaStreamSource(stream);
        source.connect(state.analyser);
        state.analyser.fftSize = 128;

        // Set up media recorder
        state.mediaRecorder = new MediaRecorder(stream);
        state.audioChunks = [];

        state.mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            state.audioChunks.push(event.data);
          }
        };

        state.mediaRecorder.start(1000);
        state.isRecording = true;
        state.isPaused = false;
        state.recordingStartTime = Date.now();
        state.elapsedTime = 0;
        state.pausedTime = 0;

        showScreen('recording');
        startTimer();
        startWaveform();

      } catch (error) {
        console.error('Error accessing microphone:', error);
        alert('Could not access microphone. Please ensure you have granted permission.');
      }
    }

    function startTimer() {
      state.timerInterval = setInterval(() => {
        if (!state.isPaused) {
          state.elapsedTime = Date.now() - state.recordingStartTime - state.pausedTime;
          updateTimerDisplay();
        }
      }, 100);
    }

    function updateTimerDisplay() {
      const totalSeconds = Math.floor(state.elapsedTime / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      elements.timer.textContent = 
        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

      const isShort = totalSeconds < 15 * 60;
      elements.shortRecordingWarning.style.display = isShort ? 'flex' : 'none';
    }

    function startWaveform() {
      const bars = elements.waveform.querySelectorAll('.wave-bar');
      const dataArray = new Uint8Array(state.analyser.frequencyBinCount);

      state.waveformInterval = setInterval(() => {
        if (state.isPaused) {
          bars.forEach(bar => bar.style.height = '10px');
          return;
        }

        state.analyser.getByteFrequencyData(dataArray);
        
        bars.forEach((bar, i) => {
          const value = dataArray[i] || 0;
          const height = Math.max(10, (value / 255) * 60);
          bar.style.height = `${height}px`;
        });
      }, 50);
    }

    function togglePauseResume() {
      if (state.isPaused) {
        state.mediaRecorder.resume();
        state.isPaused = false;
        state.pausedTime += Date.now() - state.pauseStartTime;
        state.pauseStartTime = null;
        
        elements.recordingDot.classList.remove('paused');
        elements.recordingStatusText.textContent = 'Recording';
        elements.pauseResumeBtn.classList.remove('resume');
        elements.pauseResumeBtn.classList.add('pause');
        elements.pauseIcon.style.display = 'block';
        elements.playIcon.style.display = 'none';
      } else {
        state.mediaRecorder.pause();
        state.isPaused = true;
        state.pauseStartTime = Date.now();
        
        elements.recordingDot.classList.add('paused');
        elements.recordingStatusText.textContent = 'Paused';
        elements.pauseResumeBtn.classList.remove('pause');
        elements.pauseResumeBtn.classList.add('resume');
        elements.pauseIcon.style.display = 'none';
        elements.playIcon.style.display = 'block';
      }
    }

    function showFinishConfirmation() {
      const totalSeconds = Math.floor(state.elapsedTime / 1000);
      
      if (totalSeconds < 15 * 60) {
        elements.modalTitle.textContent = 'Recording is Short';
        elements.modalMessage.textContent = `You've only recorded ${Math.floor(totalSeconds / 60)} minutes. Are you sure the appointment is complete?`;
      } else {
        elements.modalTitle.textContent = 'Finish Recording?';
        elements.modalMessage.textContent = 'Your recording will be processed and you\'ll receive the transcript via email within 15 minutes.';
      }
      
      elements.confirmModal.style.display = 'flex';
    }

    function hideConfirmModal() {
      elements.confirmModal.style.display = 'none';
    }

    async function finishRecording() {
      // Release wake lock
      if (state.wakeLock) {
        state.wakeLock.release();
        state.wakeLock = null;
      }
      hideConfirmModal();
      
      // Stop recording
      clearInterval(state.timerInterval);
      clearInterval(state.waveformInterval);
      
      state.mediaRecorder.stop();
      
      // Wait for final data
      await new Promise(resolve => {
        state.mediaRecorder.onstop = resolve;
      });

      // Stop all tracks
      state.mediaRecorder.stream.getTracks().forEach(track => track.stop());
      
      if (state.audioContext) {
        state.audioContext.close();
      }

      // Create audio blob
      const audioBlob = new Blob(state.audioChunks, { type: 'audio/webm' });

      // Build metadata payload (audio added at upload time)
      const payload = {
        agentName: state.user.name,
        clientName: state.clientName,
        appointmentType: state.appointmentType,
        date: new Date().toISOString().split('T')[0],
        notes: state.notes,
        userEmail: state.user.email,
        tcName: state.selectedTC.name,
        tcEmail: state.selectedTC.email
      };

      await uploadRecording(payload, audioBlob);
    }

    async function uploadRecording(payload, audioBlob) {
      // If offline, save immediately without showing uploading spinner
      if (!navigator.onLine) {
        await saveOffline(payload, audioBlob);
        return;
      }

      // Show uploading screen
      elements.uploadingTitle.textContent = 'Uploading...';
      elements.uploadingMessage.textContent = 'Please wait while we upload your recording.';
      showScreen('uploading');

      try {
        const base64Audio = await blobToBase64(audioBlob);
        const fullPayload = { ...payload, audio: base64Audio.split(',')[1] };

        const response = await fetch(CONFIG.appsScriptUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain' },
          body: JSON.stringify(fullPayload)
        });

        // If fetch didn't throw, assume success
        showScreen('success');

      } catch (error) {
        console.error('Upload failed, saving offline:', error);
        await saveOffline(payload, audioBlob);
      }
    }

    async function saveOffline(payload, audioBlob) {
      try {
        elements.uploadingTitle.textContent = 'Saving locally...';
        elements.uploadingMessage.textContent = 'No connection detected. Saving your recording to this device.';
        showScreen('uploading');

        await saveToQueue(payload, audioBlob);
        await updateQueueBanner();

        setTimeout(() => {
          showScreen('savedOffline');
        }, 800);

      } catch (err) {
        console.error('Failed to save offline:', err);
        alert('Error saving recording. Please try again or contact support.');
        showScreen('setup');
      }
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    function resetForNewRecording() {
      state.clientName = '';
      state.appointmentType = '';
      state.selectedTC = null;
      state.notes = '';
      state.audioChunks = [];
      
      elements.clientName.value = '';
      elements.tcSelect.value = '';
      elements.notes.value = '';
      document.querySelectorAll('.type-btn').forEach(btn => btn.classList.remove('selected'));
      elements.startRecordingBtn.disabled = true;
      
      showScreen('setup');
    }

    // ============================================
    // Service Worker Registration (optional PWA)
    // ============================================

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then(() => {
        console.log('Service worker registered');
      }).catch(err => {
        // sw.js not present is fine — offline queue still works via IndexedDB
        console.log('Service worker registration skipped:', err.message);
      });
    }

    // ============================================
    // Event Listeners
    // ============================================
    
    elements.loginBtn.addEventListener('click', login);
    elements.loginPassword.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') login();
    });
    elements.loginEmail.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') elements.loginPassword.focus();
    });
    elements.logoutBtn.addEventListener('click', logout);

    document.querySelectorAll('.type-btn').forEach(btn => {
      btn.addEventListener('click', () => selectAppointmentType(btn.dataset.type));
    });

    elements.clientName.addEventListener('input', validateForm);
    elements.tcSelect.addEventListener('change', validateForm);

    elements.startRecordingBtn.addEventListener('click', startRecording);
    elements.pauseResumeBtn.addEventListener('click', togglePauseResume);
    elements.finishBtn.addEventListener('click', showFinishConfirmation);
    elements.modalCancel.addEventListener('click', hideConfirmModal);
    elements.modalConfirm.addEventListener('click', finishRecording);
    elements.newRecordingBtn.addEventListener('click', resetForNewRecording);
    elements.newRecordingOfflineBtn.addEventListener('click', resetForNewRecording);

    // Online / Offline listeners
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);

    // ============================================
    // Init
    // ============================================
    
    async function init() {
      await openDB();
      populateTCDropdown();
      checkStoredLogin();
      updateOnlineStatus();
      updateQueueBanner();

      // Request persistent storage so the browser won't evict offline recordings
      if (navigator.storage && navigator.storage.persist) {
        const granted = await navigator.storage.persist();
        console.log('Persistent storage:', granted ? 'granted' : 'denied');
      }
    }

    init();
  </script>
</body>
</html>
