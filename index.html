<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">
  <title>WIR Appointment Notetaker</title>
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <style>
    :root {
      --wir-blue-light: #5BC4F1;
      --wir-blue-mid: #3AA4DA;
      --wir-blue-dark: #1E5F99;
      --wir-green: #A4D233;
      --wir-black: #000000;
      --wir-white: #FFFFFF;
      --gradient-wir: linear-gradient(135deg, var(--wir-blue-light) 0%, var(--wir-blue-dark) 50%, var(--wir-green) 100%);
      --gradient-blue: linear-gradient(135deg, var(--wir-blue-light) 0%, var(--wir-blue-dark) 100%);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: var(--wir-black);
      min-height: 100vh;
      color: var(--wir-white);
    }

    .container {
      max-width: 480px;
      margin: 0 auto;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .header {
      text-align: center;
      padding: 20px 0;
    }

    .header h1 {
      font-size: 22px;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .header p {
      font-size: 14px;
      opacity: 0.7;
    }

    .logo {
      height: 50px;
      margin: 0 auto 20px;
      display: block;
    }

    .logo-icon {
      width: 70px;
      height: 70px;
      margin: 0 auto 16px;
      display: block;
    }

    /* Cards */
    .card {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .card-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 20px;
      color: var(--wir-white);
    }

    /* Form Elements */
    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      font-size: 13px;
      font-weight: 500;
      margin-bottom: 8px;
      opacity: 0.9;
    }

    .form-input {
      width: 100%;
      padding: 14px 16px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      color: var(--wir-white);
      font-size: 16px;
      outline: none;
      transition: all 0.2s;
    }

    .form-input:focus {
      border-color: var(--wir-blue-light);
      background: rgba(255, 255, 255, 0.15);
      box-shadow: 0 0 0 3px rgba(91, 196, 241, 0.2);
    }

    .form-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    select.form-input {
      cursor: pointer;
    }

    select.form-input option {
      background: var(--wir-black);
      color: var(--wir-white);
    }

    /* Buttons */
    .btn {
      width: 100%;
      padding: 16px 24px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn-primary {
      background: var(--gradient-blue);
      color: var(--wir-white);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(91, 196, 241, 0.3);
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: var(--wir-white);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .btn-success {
      background: linear-gradient(135deg, var(--wir-green) 0%, #8BC02A 100%);
      color: var(--wir-black);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: var(--wir-white);
    }

    /* Appointment Type Buttons */
    .type-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .type-btn {
      padding: 16px;
      background: rgba(255, 255, 255, 0.08);
      border: 2px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      color: var(--wir-white);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .type-btn:hover {
      background: rgba(91, 196, 241, 0.1);
      border-color: rgba(91, 196, 241, 0.3);
    }

    .type-btn.selected {
      background: rgba(91, 196, 241, 0.2);
      border-color: var(--wir-blue-light);
      color: var(--wir-blue-light);
    }

    /* Recording Screen */
    .recording-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
    }

    .recording-status {
      font-size: 14px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .recording-dot {
      width: 12px;
      height: 12px;
      background: #ef4444;
      border-radius: 50%;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .recording-dot.paused {
      background: var(--wir-green);
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    .timer {
      font-size: 64px;
      font-weight: 300;
      font-variant-numeric: tabular-nums;
      margin-bottom: 40px;
      background: var(--gradient-wir);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .waveform {
      width: 100%;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      margin-bottom: 40px;
    }

    .wave-bar {
      width: 6px;
      background: var(--gradient-wir);
      border-radius: 3px;
      transition: height 0.1s ease;
    }

    .recording-info {
      text-align: center;
      margin-bottom: 40px;
    }

    .recording-info h3 {
      font-size: 20px;
      margin-bottom: 4px;
    }

    .recording-info p {
      font-size: 14px;
      opacity: 0.7;
    }

    /* Control Buttons */
    .control-buttons {
      display: flex;
      gap: 16px;
      width: 100%;
      max-width: 300px;
    }

    .control-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .control-btn.pause {
      background: rgba(255, 255, 255, 0.15);
      flex: 1;
    }

    .control-btn.resume {
      background: var(--wir-green);
      flex: 1;
    }

    .control-btn.finish {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      flex: 1;
    }

    .control-btn:hover {
      transform: scale(1.05);
    }

    .control-btn svg {
      width: 28px;
      height: 28px;
      fill: var(--wir-white);
    }

    /* Short Recording Warning */
    .short-recording-warning {
      display: none;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: rgba(251, 191, 36, 0.2);
      border: 1px solid rgba(251, 191, 36, 0.4);
      border-radius: 12px;
      margin-top: 20px;
      font-size: 13px;
      color: #fbbf24;
    }

    .short-recording-warning svg {
      width: 20px;
      height: 20px;
      fill: #fbbf24;
      flex-shrink: 0;
    }

    /* Success Screen */
    .success-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 20px;
    }

    .success-icon {
      width: 100px;
      height: 100px;
      background: var(--wir-green);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 24px;
    }

    .success-icon svg {
      width: 50px;
      height: 50px;
      fill: var(--wir-black);
    }

    .success-screen h2 {
      font-size: 28px;
      margin-bottom: 12px;
    }

    .success-screen p {
      font-size: 16px;
      opacity: 0.8;
      margin-bottom: 32px;
      line-height: 1.5;
    }

    /* Uploading Screen */
    .uploading-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 20px;
    }

    .spinner {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--wir-blue-light);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 24px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .uploading-screen h2 {
      font-size: 24px;
      margin-bottom: 12px;
    }

    .uploading-screen p {
      font-size: 14px;
      opacity: 0.7;
    }

    /* Progress Bar */
    .upload-progress {
      width: 100%;
      max-width: 280px;
      margin-top: 20px;
    }

    .progress-bar-container {
      width: 100%;
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 8px;
    }

    .progress-bar {
      height: 100%;
      background: var(--gradient-blue);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .progress-text {
      font-size: 13px;
      opacity: 0.7;
      text-align: center;
    }

    /* Login Screen */
    .login-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .login-error {
      display: none;
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.4);
      color: #ef4444;
      padding: 12px 16px;
      border-radius: 12px;
      margin-bottom: 16px;
      font-size: 14px;
    }

    /* User Badge */
    .user-badge {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      margin-bottom: 20px;
    }

    .user-avatar {
      width: 40px;
      height: 40px;
      background: var(--gradient-blue);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 16px;
    }

    .user-info {
      flex: 1;
    }

    .user-name {
      font-weight: 600;
      font-size: 15px;
    }

    .user-email {
      font-size: 13px;
      opacity: 0.7;
    }

    .logout-btn {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 8px;
      color: var(--wir-white);
      font-size: 13px;
      cursor: pointer;
    }

    /* Modal */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(4px);
      z-index: 100;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .modal-content {
      background: #1a1a1a;
      border-radius: 20px;
      padding: 24px;
      max-width: 340px;
      width: 100%;
      text-align: center;
    }

    .modal-title {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .modal-message {
      font-size: 14px;
      opacity: 0.8;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
    }

    .modal-buttons .btn {
      flex: 1;
      padding: 14px;
    }

    /* Screen visibility */
    .screen {
      display: none;
      flex-direction: column;
      min-height: 100vh;
    }

    .screen.active {
      display: flex;
    }

    /* Offline Banner */
    .offline-banner {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #dc2626;
      color: white;
      padding: 10px 20px;
      text-align: center;
      font-size: 14px;
      font-weight: 500;
      z-index: 1000;
    }

    .offline-banner.visible {
      display: block;
    }

    /* Queue Banner */
    .queue-banner {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #d97706;
      color: white;
      padding: 12px 20px;
      z-index: 1000;
    }

    .queue-banner.visible {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .queue-banner-text {
      font-size: 14px;
      font-weight: 500;
    }

    .queue-retry-btn {
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      border-radius: 6px;
      color: white;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
    }

    .queue-retry-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Saved Offline Screen */
    .saved-offline-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 40px 20px;
    }

    .saved-offline-icon {
      width: 100px;
      height: 100px;
      background: #d97706;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 24px;
    }

    .saved-offline-icon svg {
      width: 50px;
      height: 50px;
      fill: var(--wir-white);
    }

    .saved-offline-screen h2 {
      font-size: 28px;
      margin-bottom: 12px;
    }

    .saved-offline-screen p {
      font-size: 16px;
      opacity: 0.8;
      margin-bottom: 32px;
      line-height: 1.5;
    }
  </style>
</head>
<body>

<div class="offline-banner" id="offlineBanner">
  ðŸ“¡ No internet connection â€“ recordings will be saved locally
</div>

<div class="queue-banner" id="queueBanner">
  <span class="queue-banner-text" id="queueBannerText">1 recording waiting to upload</span>
  <button class="queue-retry-btn" id="queueRetryBtn">Retry</button>
</div>

<div class="container">

  <!-- LOGIN SCREEN -->
  <div class="screen active" id="loginScreen">
    <div class="login-screen">
      <div class="header">
   <img src="WIR LOGO.png" alt="WIR Logo" style="width: 220px; margin: 0 auto 20px; display: block;">
        <h1>WIR Appointment Notetaker</h1>
        <p>Sign in with your email to start </p>
      </div>

      <div class="card">
        <div class="login-error" id="loginError"></div>
        
        <div class="form-group">
          <label class="form-label">Email</label>
          <input type="email" class="form-input" id="loginEmail" placeholder="your.name@wattersinternational.com" autocomplete="email">
        </div>
        
        <div class="form-group">
          <label class="form-label">Password</label>
          <input type="password" class="form-input" id="loginPassword" placeholder="Enter password" autocomplete="current-password">
        </div>
        
        <button class="btn btn-primary" id="loginBtn">
          Sign In
        </button>
      </div>
    </div>
  </div>

  <!-- SETUP SCREEN -->
  <div class="screen" id="setupScreen">
    <div class="header">
      <h1>New Recording</h1>
      <p>Fill in the appointment details</p>
    </div>

    <div class="user-badge">
      <div class="user-avatar" id="userAvatar">A</div>
      <div class="user-info">
        <div class="user-name" id="userName">Agent Name</div>
        <div class="user-email" id="userEmailDisplay">email@wir.com</div>
      </div>
      <button class="logout-btn" id="logoutBtn">Sign Out</button>
    </div>

    <div class="card">
      <div class="form-group">
        <label class="form-label">Client Name</label>
        <input type="text" class="form-input" id="clientName" placeholder="Enter client's full name">
      </div>

      <div class="form-group">
        <label class="form-label">Appointment Type</label>
        <div class="type-grid">
          <button class="type-btn" data-type="Listing Appointment">Listing</button>
          <button class="type-btn" data-type="Buyer Consultation">Buyer Consult</button>
          <button class="type-btn" data-type="Follow-up">Follow-up</button>
          <button class="type-btn" data-type="Other">Other</button>
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">Transaction Coordinator</label>
        <select class="form-input" id="tcSelect">
          <option value="">Select TC...</option>
        </select>
      </div>

      <div class="form-group">
        <label class="form-label">Notes (Optional)</label>
        <input type="text" class="form-input" id="notes" placeholder="Any additional context">
      </div>

      <button class="btn btn-success" id="startRecordingBtn" disabled>
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <circle cx="12" cy="12" r="8"/>
        </svg>
        Start Recording
      </button>
    </div>
  </div>

  <!-- RECORDING SCREEN -->
  <div class="screen" id="recordingScreen">
    <div class="recording-screen">
      <div class="recording-status">
        <div class="recording-dot" id="recordingDot"></div>
        <span id="recordingStatusText">Recording</span>
      </div>

      <div class="timer" id="timer">00:00:00</div>

      <div class="waveform" id="waveform"></div>

      <div class="recording-info">
        <h3 id="recordingClient">Client Name</h3>
        <p id="recordingType">Appointment Type</p>
      </div>

      <div class="control-buttons">
        <button class="control-btn pause" id="pauseResumeBtn">
          <svg id="pauseIcon" viewBox="0 0 24 24">
            <rect x="6" y="4" width="4" height="16"/>
            <rect x="14" y="4" width="4" height="16"/>
          </svg>
          <svg id="playIcon" style="display: none;" viewBox="0 0 24 24">
            <path d="M8 5v14l11-7z"/>
          </svg>
        </button>
        <button class="control-btn finish" id="finishBtn">
          <svg viewBox="0 0 24 24">
            <rect x="6" y="6" width="12" height="12" rx="2"/>
          </svg>
        </button>
      </div>

      <div class="short-recording-warning" id="shortRecordingWarning">
        <svg viewBox="0 0 24 24">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
        </svg>
        <span>Recording is under 15 minutes</span>
      </div>
    </div>
  </div>

  <!-- UPLOADING SCREEN -->
  <div class="screen" id="uploadingScreen">
    <div class="uploading-screen">
      <div class="spinner"></div>
      <h2 id="uploadingTitle">Uploading...</h2>
      <p id="uploadingMessage">Please wait while we upload your recording.</p>
      <div class="upload-progress" id="uploadProgress">
        <div class="progress-bar-container">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="progress-text" id="progressText">0%</div>
      </div>
    </div>
  </div>

  <!-- SUCCESS SCREEN -->
  <div class="screen" id="successScreen">
    <div class="success-screen">
      <div class="success-icon">
        <svg viewBox="0 0 24 24">
          <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
        </svg>
      </div>
      <h2>Upload Complete!</h2>
      <p>Your recording has been submitted. You'll receive the transcript via email within 15 minutes.</p>
      <button class="btn btn-primary" id="newRecordingBtn">Start New Recording</button>
    </div>
  </div>

  <!-- SAVED OFFLINE SCREEN -->
  <div class="screen" id="savedOfflineScreen">
    <div class="saved-offline-screen">
      <div class="saved-offline-icon">
        <svg viewBox="0 0 24 24">
          <path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/>
        </svg>
      </div>
      <h2>Saved Locally</h2>
      <p>Your recording is safely stored on this device. It will upload automatically when you're back online.</p>
      <button class="btn btn-primary" id="newRecordingOfflineBtn">Start New Recording</button>
    </div>
  </div>

</div>

<!-- CONFIRM MODAL -->
<div class="modal" id="confirmModal">
  <div class="modal-content">
    <h3 class="modal-title" id="modalTitle">Finish Recording?</h3>
    <p class="modal-message" id="modalMessage">Your recording will be processed and you'll receive the transcript via email within 15 minutes.</p>
    <div class="modal-buttons">
      <button class="btn btn-secondary" id="modalCancel">Cancel</button>
      <button class="btn btn-danger" id="modalConfirm">Finish</button>
    </div>
  </div>
</div>

<script>
  // ============================================
  // Configuration
  // ============================================
  
  const CONFIG = {
    appsScriptUrl: 'https://script.google.com/macros/s/AKfycbzNbvlZCTMCPKYbPQJ5pvgS66iKN8naDqG09ATA7EmNHzmPBTaKLmWQ4SGYC13GdPP4Pw/exec',
    password: '#ONESTEPAHEAD2026',
    teamMembers: [
      { name: 'Tanya Wohleb', email: 'tanya.wohleb@wattersinternational.com' },
      { name: 'Debbie Lopez', email: 'debbie.lopez@wattersinternational.com' },
      { name: 'Tracy Hykel', email: 'tracy.hykel@wattersinternational.com' },
      { name: 'Jodi Raughton', email: 'jodi.raughton@wattersinternational.com' }
    ],
    dbName: 'WIRRecorderDB',
    storeName: 'pendingUploads',
    // Chunked upload config
    chunkSize: 4 * 1024 * 1024, // 4MB chunks (safe under Apps Script 50MB limit after base64 encoding)
    maxRetries: 3
  };

  // ============================================
  // State
  // ============================================
  
  const state = {
    user: null,
    clientName: '',
    appointmentType: '',
    selectedTC: null,
    notes: '',
    mediaRecorder: null,
    audioChunks: [],
    isRecording: false,
    isPaused: false,
    recordingStartTime: null,
    elapsedTime: 0,
    pausedTime: 0,
    pauseStartTime: null,
    timerInterval: null,
    waveformInterval: null,
    audioContext: null,
    analyser: null,
    wakeLock: null,
    db: null,
    isOnline: navigator.onLine,
    isUploading: false
  };

  // ============================================
  // DOM Elements
  // ============================================
  
  const screens = {
    login: document.getElementById('loginScreen'),
    setup: document.getElementById('setupScreen'),
    recording: document.getElementById('recordingScreen'),
    uploading: document.getElementById('uploadingScreen'),
    success: document.getElementById('successScreen'),
    savedOffline: document.getElementById('savedOfflineScreen')
  };

  const elements = {
    loginEmail: document.getElementById('loginEmail'),
    loginPassword: document.getElementById('loginPassword'),
    loginBtn: document.getElementById('loginBtn'),
    loginError: document.getElementById('loginError'),
    logoutBtn: document.getElementById('logoutBtn'),
    userAvatar: document.getElementById('userAvatar'),
    userName: document.getElementById('userName'),
    userEmailDisplay: document.getElementById('userEmailDisplay'),
    clientName: document.getElementById('clientName'),
    tcSelect: document.getElementById('tcSelect'),
    notes: document.getElementById('notes'),
    startRecordingBtn: document.getElementById('startRecordingBtn'),
    timer: document.getElementById('timer'),
    waveform: document.getElementById('waveform'),
    recordingClient: document.getElementById('recordingClient'),
    recordingType: document.getElementById('recordingType'),
    recordingDot: document.getElementById('recordingDot'),
    recordingStatusText: document.getElementById('recordingStatusText'),
    pauseResumeBtn: document.getElementById('pauseResumeBtn'),
    pauseIcon: document.getElementById('pauseIcon'),
    playIcon: document.getElementById('playIcon'),
    finishBtn: document.getElementById('finishBtn'),
    shortRecordingWarning: document.getElementById('shortRecordingWarning'),
    confirmModal: document.getElementById('confirmModal'),
    modalTitle: document.getElementById('modalTitle'),
    modalMessage: document.getElementById('modalMessage'),
    modalCancel: document.getElementById('modalCancel'),
    modalConfirm: document.getElementById('modalConfirm'),
    newRecordingBtn: document.getElementById('newRecordingBtn'),
    newRecordingOfflineBtn: document.getElementById('newRecordingOfflineBtn'),
    uploadingTitle: document.getElementById('uploadingTitle'),
    uploadingMessage: document.getElementById('uploadingMessage'),
    offlineBanner: document.getElementById('offlineBanner'),
    queueBanner: document.getElementById('queueBanner'),
    queueBannerText: document.getElementById('queueBannerText'),
    queueRetryBtn: document.getElementById('queueRetryBtn'),
    uploadProgress: document.getElementById('uploadProgress'),
    progressBar: document.getElementById('progressBar'),
    progressText: document.getElementById('progressText')
  };

  // ============================================
  // IndexedDB for Offline Queue
  // ============================================

  function openDB() {
    return new Promise((resolve, reject) => {
      if (state.db) {
        resolve(state.db);
        return;
      }
      const request = indexedDB.open(CONFIG.dbName, 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        state.db = request.result;
        resolve(state.db);
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(CONFIG.storeName)) {
          db.createObjectStore(CONFIG.storeName, { keyPath: 'id', autoIncrement: true });
        }
      };
    });
  }

  async function saveToQueue(payload, audioBlob) {
    const db = state.db || await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(CONFIG.storeName, 'readwrite');
      const store = tx.objectStore(CONFIG.storeName);
      const record = {
        payload,
        audioBlob,
        createdAt: new Date().toISOString()
      };
      const request = store.add(record);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async function getQueuedRecordings() {
    const db = state.db || await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(CONFIG.storeName, 'readonly');
      const store = tx.objectStore(CONFIG.storeName);
      const request = store.getAll();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  async function removeFromQueue(id) {
    const db = state.db || await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(CONFIG.storeName, 'readwrite');
      const store = tx.objectStore(CONFIG.storeName);
      const request = store.delete(id);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async function getQueueCount() {
    const db = state.db || await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(CONFIG.storeName, 'readonly');
      const store = tx.objectStore(CONFIG.storeName);
      const request = store.count();
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  // ============================================
  // Online / Offline Detection
  // ============================================

  function updateOnlineStatus() {
    state.isOnline = navigator.onLine;
    
    if (state.isOnline) {
      elements.offlineBanner.classList.remove('visible');
      retryQueuedUploads();
    } else {
      elements.offlineBanner.classList.add('visible');
    }
  }

  async function updateQueueBanner() {
    try {
      const count = await getQueueCount();
      if (count > 0) {
        elements.queueBannerText.textContent = 
          count === 1 
            ? '1 recording waiting to upload' 
            : `${count} recordings waiting to upload`;
        elements.queueBanner.classList.add('visible');
      } else {
        elements.queueBanner.classList.remove('visible');
      }
    } catch (e) {
      console.error('Error checking queue:', e);
    }
  }

  async function retryQueuedUploads() {
    if (state.isUploading || !navigator.onLine) return;
    
    state.isUploading = true;
    elements.queueRetryBtn.disabled = true;
    elements.queueRetryBtn.textContent = 'Uploading...';

    try {
      const recordings = await getQueuedRecordings();
      
      for (const record of recordings) {
        if (!navigator.onLine) break;
        
        try {
          const success = await uploadWithChunks(record.payload, record.audioBlob, null);
          if (success) {
            await removeFromQueue(record.id);
            console.log('Queued recording uploaded successfully, id:', record.id);
          }
        } catch (err) {
          console.warn('Failed to upload queued recording id:', record.id, err);
        }
      }
    } catch (e) {
      console.error('Error processing queue:', e);
    } finally {
      state.isUploading = false;
      elements.queueRetryBtn.disabled = false;
      elements.queueRetryBtn.textContent = 'Retry';
      updateQueueBanner();
    }
  }

  // ============================================
  // Screen Navigation
  // ============================================
  
  function showScreen(screenName) {
    Object.values(screens).forEach(s => s.classList.remove('active'));
    screens[screenName].classList.add('active');
  }

  // ============================================
  // Login
  // ============================================
  
  function checkStoredLogin() {
    const stored = localStorage.getItem('wirUser');
    if (stored) {
      state.user = JSON.parse(stored);
      updateUserDisplay();
      showScreen('setup');
    }
  }

  function login() {
    const email = elements.loginEmail.value.trim();
    const password = elements.loginPassword.value;

    if (!email) {
      showLoginError('Please enter your email');
      return;
    }

    if (password !== CONFIG.password) {
      showLoginError('Invalid password');
      return;
    }

    state.user = {
      email: email,
      name: email.split('@')[0].replace(/[._]/g, ' ').replace(/\b\w/g, c => c.toUpperCase())
    };

    localStorage.setItem('wirUser', JSON.stringify(state.user));
    updateUserDisplay();
    showScreen('setup');
  }

  function logout() {
    localStorage.removeItem('wirUser');
    state.user = null;
    elements.loginEmail.value = '';
    elements.loginPassword.value = '';
    showScreen('login');
  }

  function showLoginError(message) {
    elements.loginError.textContent = message;
    elements.loginError.style.display = 'block';
    setTimeout(() => {
      elements.loginError.style.display = 'none';
    }, 3000);
  }

  function updateUserDisplay() {
    if (state.user) {
      elements.userAvatar.textContent = state.user.name.charAt(0).toUpperCase();
      elements.userName.textContent = state.user.name;
      elements.userEmailDisplay.textContent = state.user.email;
    }
  }

  // ============================================
  // Setup Form
  // ============================================
  
  function populateTCDropdown() {
    CONFIG.teamMembers.forEach(tc => {
      const option = document.createElement('option');
      option.value = JSON.stringify(tc);
      option.textContent = tc.name;
      elements.tcSelect.appendChild(option);
    });
  }

  function selectAppointmentType(type) {
    state.appointmentType = type;
    document.querySelectorAll('.type-btn').forEach(btn => {
      btn.classList.toggle('selected', btn.dataset.type === type);
    });
    validateForm();
  }

  function validateForm() {
    const isValid = 
      elements.clientName.value.trim() !== '' &&
      state.appointmentType !== '' &&
      elements.tcSelect.value !== '';
    
    elements.startRecordingBtn.disabled = !isValid;
  }

  // ============================================
  // Recording
  // ============================================
  
  async function startRecording() {
    if ('wakeLock' in navigator) {
      try {
        state.wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake lock active');
      } catch (err) {
        console.log('Wake lock failed:', err);
      }
    }

    state.clientName = elements.clientName.value.trim();
    state.selectedTC = JSON.parse(elements.tcSelect.value);
    state.notes = elements.notes.value.trim();

    elements.recordingClient.textContent = state.clientName;
    elements.recordingType.textContent = state.appointmentType;

    elements.waveform.innerHTML = '';
    for (let i = 0; i < 40; i++) {
      const bar = document.createElement('div');
      bar.className = 'wave-bar';
      bar.style.height = '10px';
      elements.waveform.appendChild(bar);
    }

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      state.analyser = state.audioContext.createAnalyser();
      const source = state.audioContext.createMediaStreamSource(stream);
      source.connect(state.analyser);
      state.analyser.fftSize = 128;

      state.mediaRecorder = new MediaRecorder(stream);
      state.audioChunks = [];

      state.mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          state.audioChunks.push(event.data);
        }
      };

      state.mediaRecorder.start(1000);
      state.isRecording = true;
      state.isPaused = false;
      state.recordingStartTime = Date.now();
      state.elapsedTime = 0;
      state.pausedTime = 0;

      showScreen('recording');
      startTimer();
      startWaveform();

    } catch (error) {
      console.error('Error accessing microphone:', error);
      alert('Could not access microphone. Please ensure you have granted permission.');
    }
  }

  function startTimer() {
    state.timerInterval = setInterval(() => {
      if (!state.isPaused) {
        state.elapsedTime = Date.now() - state.recordingStartTime - state.pausedTime;
        updateTimerDisplay();
      }
    }, 100);
  }

  function updateTimerDisplay() {
    const totalSeconds = Math.floor(state.elapsedTime / 1000);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;

    elements.timer.textContent = 
      `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

    const isShort = totalSeconds < 15 * 60;
    elements.shortRecordingWarning.style.display = isShort ? 'flex' : 'none';
  }

  function startWaveform() {
    const bars = elements.waveform.querySelectorAll('.wave-bar');
    const dataArray = new Uint8Array(state.analyser.frequencyBinCount);

    state.waveformInterval = setInterval(() => {
      if (state.isPaused) {
        bars.forEach(bar => bar.style.height = '10px');
        return;
      }

      state.analyser.getByteFrequencyData(dataArray);
      
      bars.forEach((bar, i) => {
        const value = dataArray[i] || 0;
        const height = Math.max(10, (value / 255) * 60);
        bar.style.height = `${height}px`;
      });
    }, 50);
  }

  function togglePauseResume() {
    if (state.isPaused) {
      state.mediaRecorder.resume();
      state.isPaused = false;
      state.pausedTime += Date.now() - state.pauseStartTime;
      state.pauseStartTime = null;
      
      elements.recordingDot.classList.remove('paused');
      elements.recordingStatusText.textContent = 'Recording';
      elements.pauseResumeBtn.classList.remove('resume');
      elements.pauseResumeBtn.classList.add('pause');
      elements.pauseIcon.style.display = 'block';
      elements.playIcon.style.display = 'none';
    } else {
      state.mediaRecorder.pause();
      state.isPaused = true;
      state.pauseStartTime = Date.now();
      
      elements.recordingDot.classList.add('paused');
      elements.recordingStatusText.textContent = 'Paused';
      elements.pauseResumeBtn.classList.remove('pause');
      elements.pauseResumeBtn.classList.add('resume');
      elements.pauseIcon.style.display = 'none';
      elements.playIcon.style.display = 'block';
    }
  }

  function showFinishConfirmation() {
    const totalSeconds = Math.floor(state.elapsedTime / 1000);
    
    if (totalSeconds < 15 * 60) {
      elements.modalTitle.textContent = 'Recording is Short';
      elements.modalMessage.textContent = `You've only recorded ${Math.floor(totalSeconds / 60)} minutes. Are you sure the appointment is complete?`;
    } else {
      elements.modalTitle.textContent = 'Finish Recording?';
      elements.modalMessage.textContent = 'Your recording will be processed and you\'ll receive the transcript via email within 15 minutes.';
    }
    
    elements.confirmModal.style.display = 'flex';
  }

  function hideConfirmModal() {
    elements.confirmModal.style.display = 'none';
  }

  async function finishRecording() {
    if (state.wakeLock) {
      state.wakeLock.release();
      state.wakeLock = null;
    }
    hideConfirmModal();
    
    clearInterval(state.timerInterval);
    clearInterval(state.waveformInterval);
    
    state.mediaRecorder.stop();
    
    await new Promise(resolve => {
      state.mediaRecorder.onstop = resolve;
    });

    state.mediaRecorder.stream.getTracks().forEach(track => track.stop());
    
    if (state.audioContext) {
      state.audioContext.close();
    }

    const audioBlob = new Blob(state.audioChunks, { type: 'audio/webm' });

    const payload = {
      agentName: state.user.name,
      clientName: state.clientName,
      appointmentType: state.appointmentType,
      date: new Date().toISOString().split('T')[0],
      notes: state.notes,
      userEmail: state.user.email,
      tcName: state.selectedTC.name,
      tcEmail: state.selectedTC.email
    };

    await uploadRecording(payload, audioBlob);
  }

  // ============================================
  // Chunked Upload Logic
  // ============================================

  function updateProgress(percent, message) {
    elements.progressBar.style.width = percent + '%';
    elements.progressText.textContent = message || `${Math.round(percent)}%`;
  }

  async function uploadWithChunks(payload, audioBlob, progressCallback) {
    // Generate unique upload ID
    const uploadId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // Convert blob to base64
    const base64Audio = await blobToBase64(audioBlob);
    const base64Data = base64Audio.split(',')[1]; // Remove data URL prefix
    
    const totalSize = base64Data.length;
    const chunkSize = CONFIG.chunkSize;
    const totalChunks = Math.ceil(totalSize / chunkSize);
    
    console.log(`Starting chunked upload: ${totalChunks} chunks, ${(totalSize / 1024 / 1024).toFixed(2)}MB total`);
    
    // Upload each chunk
    for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
      const start = chunkIndex * chunkSize;
      const end = Math.min(start + chunkSize, totalSize);
      const chunkData = base64Data.slice(start, end);
      
      const chunkPayload = {
        action: 'uploadChunk',
        uploadId: uploadId,
        chunkIndex: chunkIndex,
        totalChunks: totalChunks,
        chunkData: chunkData,
        // Include metadata only on first chunk
        ...(chunkIndex === 0 ? { metadata: payload } : {})
      };
      
      let success = false;
      let lastError = null;
      
      for (let retry = 0; retry < CONFIG.maxRetries && !success; retry++) {
        try {
          const response = await fetch(CONFIG.appsScriptUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'text/plain' },
            body: JSON.stringify(chunkPayload)
          });
          
          const result = await response.json();
          
          if (result.success) {
            success = true;
            const progress = ((chunkIndex + 1) / totalChunks) * 100;
            if (progressCallback) {
              progressCallback(progress, `Uploading: chunk ${chunkIndex + 1}/${totalChunks}`);
            }
            console.log(`Chunk ${chunkIndex + 1}/${totalChunks} uploaded`);
          } else {
            lastError = result.message || 'Chunk upload failed';
            console.warn(`Chunk ${chunkIndex + 1} failed (attempt ${retry + 1}): ${lastError}`);
          }
        } catch (err) {
          lastError = err.message;
          console.warn(`Chunk ${chunkIndex + 1} error (attempt ${retry + 1}): ${err.message}`);
        }
        
        if (!success && retry < CONFIG.maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, 1000 * (retry + 1)));
        }
      }
      
      if (!success) {
        throw new Error(`Failed to upload chunk ${chunkIndex + 1}: ${lastError}`);
      }
    }
    
    // Finalize upload
    if (progressCallback) {
      progressCallback(100, 'Finalizing...');
    }
    
    const finalizePayload = {
      action: 'finalizeUpload',
      uploadId: uploadId,
      totalChunks: totalChunks,
      metadata: payload
    };
    
    const finalResponse = await fetch(CONFIG.appsScriptUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain' },
      body: JSON.stringify(finalizePayload)
    });
    
    const finalResult = await finalResponse.json();
    
    if (!finalResult.success) {
      throw new Error(finalResult.message || 'Failed to finalize upload');
    }
    
    console.log('Chunked upload complete!');
    return true;
  }

  async function uploadRecording(payload, audioBlob) {
    if (!navigator.onLine) {
      await saveOffline(payload, audioBlob);
      return;
    }

    elements.uploadingTitle.textContent = 'Uploading...';
    elements.uploadingMessage.textContent = 'Please wait while we upload your recording.';
    elements.uploadProgress.style.display = 'block';
    updateProgress(0, 'Preparing...');
    showScreen('uploading');

    try {
      await uploadWithChunks(payload, audioBlob, updateProgress);
      showScreen('success');

    } catch (error) {
      console.error('Upload failed, saving offline:', error);
      await saveOffline(payload, audioBlob);
    }
  }

  async function saveOffline(payload, audioBlob) {
    try {
      elements.uploadingTitle.textContent = 'Saving locally...';
      elements.uploadingMessage.textContent = 'No connection detected. Saving your recording to this device.';
      elements.uploadProgress.style.display = 'none';
      showScreen('uploading');

      await saveToQueue(payload, audioBlob);
      await updateQueueBanner();

      setTimeout(() => {
        showScreen('savedOffline');
      }, 800);

    } catch (err) {
      console.error('Failed to save offline:', err);
      alert('Error saving recording. Please try again or contact support.');
      showScreen('setup');
    }
  }

  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  function resetForNewRecording() {
    state.clientName = '';
    state.appointmentType = '';
    state.selectedTC = null;
    state.notes = '';
    state.audioChunks = [];
    
    elements.clientName.value = '';
    elements.tcSelect.value = '';
    elements.notes.value = '';
    document.querySelectorAll('.type-btn').forEach(btn => btn.classList.remove('selected'));
    elements.startRecordingBtn.disabled = true;
    
    showScreen('setup');
  }

  // ============================================
  // Service Worker Registration
  // ============================================

  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js').then(() => {
      console.log('Service worker registered');
    }).catch(err => {
      console.log('Service worker registration skipped:', err.message);
    });
  }

  // ============================================
  // Event Listeners
  // ============================================
  
  elements.loginBtn.addEventListener('click', login);
  elements.loginPassword.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') login();
  });
  elements.loginEmail.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') elements.loginPassword.focus();
  });
  elements.logoutBtn.addEventListener('click', logout);

  document.querySelectorAll('.type-btn').forEach(btn => {
    btn.addEventListener('click', () => selectAppointmentType(btn.dataset.type));
  });

  elements.clientName.addEventListener('input', validateForm);
  elements.tcSelect.addEventListener('change', validateForm);

  elements.startRecordingBtn.addEventListener('click', startRecording);
  elements.pauseResumeBtn.addEventListener('click', togglePauseResume);
  elements.finishBtn.addEventListener('click', showFinishConfirmation);
  elements.modalCancel.addEventListener('click', hideConfirmModal);
  elements.modalConfirm.addEventListener('click', finishRecording);
  elements.newRecordingBtn.addEventListener('click', resetForNewRecording);
  elements.newRecordingOfflineBtn.addEventListener('click', resetForNewRecording);
  elements.queueRetryBtn.addEventListener('click', retryQueuedUploads);

  window.addEventListener('online', updateOnlineStatus);
  window.addEventListener('offline', updateOnlineStatus);

  // ============================================
  // Init
  // ============================================
  
  async function init() {
    await openDB();
    populateTCDropdown();
    checkStoredLogin();
    updateOnlineStatus();
    updateQueueBanner();

    if (navigator.storage && navigator.storage.persist) {
      const granted = await navigator.storage.persist();
      console.log('Persistent storage:', granted ? 'granted' : 'not granted');
    }
  }

  init();
</script>

</body>
</html>
6H5v-2h6V5h2v6h6v2z"/></svg>Start New Recording</button>
      </div>
    </div>
  </div>

  <script>
    const CONFIG = {
      appsScriptUrl: 'https://script.google.com/macros/s/AKfycbzNbvlZCTMCPKYbPQJ5pvgS66iKN8naDqG09ATA7EmNHzmPBTaKLmWQ4SGYC13GdPP4Pw/exec',
      password: '#ONESTEPAHEAD2026',
      teamMembers: [
        { name: 'Tanya Wohleb', email: 'tanya.wohleb@wattersinternational.com' },
        { name: 'Debbie Lopez', email: 'debbie.lopez@wattersinternational.com' },
        { name: 'Tracy Hykel', email: 'tracy.hykel@wattersinternational.com' },
        { name: 'Jodi Raughton', email: 'jodi.raughton@wattersinternational.com' }
      ],
      dbName: 'WIR_RecorderDB',
      dbVersion: 1,
      storeName: 'pendingUploads',
      chunkSize: 4 * 1024 * 1024,
      maxRetries: 3
    };

    let state = {
      user: null, clientName: '', appointmentType: '', selectedTC: null, notes: '',
      isRecording: false, isPaused: false, recordingStartTime: null,
      elapsedTime: 0, pausedTime: 0, pauseStartTime: null,
      mediaRecorder: null, audioChunks: [], timerInterval: null, waveformInterval: null,
      audioContext: null, analyser: null, wakeLock: null,
      isOnline: navigator.onLine, isUploading: false, db: null
    };

    const screens = {
      login: document.getElementById('loginScreen'),
      setup: document.getElementById('setupScreen'),
      recording: document.getElementById('recordingScreen'),
      uploading: document.getElementById('uploadingScreen'),
      success: document.getElementById('successScreen'),
      savedOffline: document.getElementById('savedOfflineScreen')
    };

    const elements = {
      loginEmail: document.getElementById('loginEmail'),
      loginPassword: document.getElementById('loginPassword'),
      loginBtn: document.getElementById('loginBtn'),
      loginError: document.getElementById('loginError'),
      userAvatar: document.getElementById('userAvatar'),
      userName: document.getElementById('userName'),
      userEmailDisplay: document.getElementById('userEmailDisplay'),
      logoutBtn: document.getElementById('logoutBtn'),
      clientName: document.getElementById('clientName'),
      tcSelect: document.getElementById('tcSelect'),
      notes: document.getElementById('notes'),
      startRecordingBtn: document.getElementById('startRecordingBtn'),
      timer: document.getElementById('timer'),
      waveform: document.getElementById('waveform'),
      recordingDot: document.getElementById('recordingDot'),
      recordingStatusText: document.getElementById('recordingStatusText'),
      recordingClient: document.getElementById('recordingClient'),
      recordingType: document.getElementById('recordingType'),
      pauseResumeBtn: document.getElementById('pauseResumeBtn'),
      pauseIcon: document.getElementById('pauseIcon'),
      playIcon: document.getElementById('playIcon'),
      finishBtn: document.getElementById('finishBtn'),
      shortRecordingWarning: document.getElementById('shortRecordingWarning'),
      confirmModal: document.getElementById('confirmModal'),
      modalTitle: document.getElementById('modalTitle'),
      modalMessage: document.getElementById('modalMessage'),
      modalCancel: document.getElementById('modalCancel'),
      modalConfirm: document.getElementById('modalConfirm'),
      newRecordingBtn: document.getElementById('newRecordingBtn'),
      newRecordingOfflineBtn: document.getElementById('newRecordingOfflineBtn'),
      offlineBanner: document.getElementById('offlineBanner'),
      queueBanner: document.getElementById('queueBanner'),
      queueBannerText: document.getElementById('queueBannerText'),
      queueRetryBtn: document.getElementById('queueRetryBtn'),
      uploadingTitle: document.getElementById('uploadingTitle'),
      uploadingMessage: document.getElementById('uploadingMessage'),
      uploadProgress: document.getElementById('uploadProgress'),
      progressBarFill: document.getElementById('progressBarFill'),
      progressText: document.getElementById('progressText')
    };

    // IndexedDB
    function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(CONFIG.dbName, CONFIG.dbVersion);
        request.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(CONFIG.storeName)) {
            db.createObjectStore(CONFIG.storeName, { keyPath: 'id', autoIncrement: true });
          }
        };
        request.onsuccess = (e) => { state.db = e.target.result; resolve(state.db); };
        request.onerror = (e) => reject(e.target.error);
      });
    }

    async function saveToQueue(payload, audioBlob) {
      const db = state.db || await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(CONFIG.storeName, 'readwrite');
        const store = tx.objectStore(CONFIG.storeName);
        const request = store.add({ payload, audioBlob, createdAt: new Date().toISOString() });
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function getQueuedRecordings() {
      const db = state.db || await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(CONFIG.storeName, 'readonly');
        const request = tx.objectStore(CONFIG.storeName).getAll();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function removeFromQueue(id) {
      const db = state.db || await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(CONFIG.storeName, 'readwrite');
        const request = tx.objectStore(CONFIG.storeName).delete(id);
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    async function getQueueCount() {
      const db = state.db || await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(CONFIG.storeName, 'readonly');
        const request = tx.objectStore(CONFIG.storeName).count();
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    // Online/Offline
    function updateOnlineStatus() {
      state.isOnline = navigator.onLine;
      if (state.isOnline) {
        elements.offlineBanner.classList.remove('visible');
        retryQueuedUploads();
      } else {
        elements.offlineBanner.classList.add('visible');
      }
    }

    async function updateQueueBanner() {
      try {
        const count = await getQueueCount();
        if (count > 0) {
          elements.queueBannerText.textContent = count === 1 ? '1 recording waiting to upload' : `${count} recordings waiting to upload`;
          elements.queueBanner.classList.add('visible');
        } else {
          elements.queueBanner.classList.remove('visible');
        }
      } catch (e) { console.error('Queue check error:', e); }
    }

    async function retryQueuedUploads() {
      if (state.isUploading || !navigator.onLine) return;
      state.isUploading = true;
      elements.queueRetryBtn.disabled = true;
      elements.queueRetryBtn.textContent = 'Uploading...';
      try {
        const recordings = await getQueuedRecordings();
        for (const record of recordings) {
          if (!navigator.onLine) break;
          try {
            await uploadWithChunks(record.payload, record.audioBlob, null);
            await removeFromQueue(record.id);
            console.log('Queued upload success:', record.id);
          } catch (err) { console.warn('Queued upload failed:', record.id, err); }
        }
      } catch (e) { console.error('Queue processing error:', e); }
      finally {
        state.isUploading = false;
        elements.queueRetryBtn.disabled = false;
        elements.queueRetryBtn.textContent = 'Retry';
        updateQueueBanner();
      }
    }

    function showScreen(name) {
      Object.values(screens).forEach(s => s.classList.remove('active'));
      screens[name].classList.add('active');
    }

    // Login
    function checkStoredLogin() {
      const stored = localStorage.getItem('wirUser');
      if (stored) { state.user = JSON.parse(stored); updateUserDisplay(); showScreen('setup'); }
    }

    function login() {
      const email = elements.loginEmail.value.trim();
      const password = elements.loginPassword.value;
      if (!email) { showLoginError('Please enter your email'); return; }
      if (password !== CONFIG.password) { showLoginError('Invalid password'); return; }
      state.user = { email, name: email.split('@')[0].replace(/[._]/g, ' ').replace(/\b\w/g, c => c.toUpperCase()) };
      localStorage.setItem('wirUser', JSON.stringify(state.user));
      updateUserDisplay();
      showScreen('setup');
    }

    function logout() {
      localStorage.removeItem('wirUser');
      state.user = null;
      elements.loginEmail.value = '';
      elements.loginPassword.value = '';
      showScreen('login');
    }

    function showLoginError(msg) {
      elements.loginError.textContent = msg;
      elements.loginError.style.display = 'block';
      setTimeout(() => elements.loginError.style.display = 'none', 3000);
    }

    function updateUserDisplay() {
      if (state.user) {
        elements.userAvatar.textContent = state.user.name.charAt(0).toUpperCase();
        elements.userName.textContent = state.user.name;
        elements.userEmailDisplay.textContent = state.user.email;
      }
    }

    // Setup
    function populateTCDropdown() {
      CONFIG.teamMembers.forEach(tc => {
        const opt = document.createElement('option');
        opt.value = JSON.stringify(tc);
        opt.textContent = tc.name;
        elements.tcSelect.appendChild(opt);
      });
    }

    function selectAppointmentType(type) {
      state.appointmentType = type;
      document.querySelectorAll('.type-btn').forEach(btn => btn.classList.toggle('selected', btn.dataset.type === type));
      validateForm();
    }

    function validateForm() {
      elements.startRecordingBtn.disabled = !(elements.clientName.value.trim() && state.appointmentType && elements.tcSelect.value);
    }

    // Recording
    async function startRecording() {
      if ('wakeLock' in navigator) {
        try { state.wakeLock = await navigator.wakeLock.request('screen'); console.log('Wake lock active'); }
        catch (err) { console.log('Wake lock failed:', err); }
      }
      state.clientName = elements.clientName.value.trim();
      state.selectedTC = JSON.parse(elements.tcSelect.value);
      state.notes = elements.notes.value.trim();
      elements.recordingClient.textContent = state.clientName;
      elements.recordingType.textContent = state.appointmentType;
      elements.waveform.innerHTML = '';
      for (let i = 0; i < 40; i++) {
        const bar = document.createElement('div');
        bar.className = 'wave-bar';
        bar.style.height = '10px';
        elements.waveform.appendChild(bar);
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        state.analyser = state.audioContext.createAnalyser();
        state.audioContext.createMediaStreamSource(stream).connect(state.analyser);
        state.analyser.fftSize = 128;
        state.mediaRecorder = new MediaRecorder(stream);
        state.audioChunks = [];
        state.mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) state.audioChunks.push(e.data); };
        state.mediaRecorder.start(1000);
        state.isRecording = true;
        state.isPaused = false;
        state.recordingStartTime = Date.now();
        state.elapsedTime = 0;
        state.pausedTime = 0;
        showScreen('recording');
        startTimer();
        startWaveform();
      } catch (err) {
        console.error('Microphone error:', err);
        alert('Could not access microphone. Please grant permission.');
      }
    }

    function startTimer() {
      state.timerInterval = setInterval(() => {
        if (!state.isPaused) { state.elapsedTime = Date.now() - state.recordingStartTime - state.pausedTime; updateTimerDisplay(); }
      }, 100);
    }

    function updateTimerDisplay() {
      const total = Math.floor(state.elapsedTime / 1000);
      const h = Math.floor(total / 3600), m = Math.floor((total % 3600) / 60), s = total % 60;
      elements.timer.textContent = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
      elements.shortRecordingWarning.style.display = total < 900 ? 'flex' : 'none';
    }

    function startWaveform() {
      const bars = elements.waveform.querySelectorAll('.wave-bar');
      const dataArray = new Uint8Array(state.analyser.frequencyBinCount);
      state.waveformInterval = setInterval(() => {
        if (state.isPaused) { bars.forEach(b => b.style.height = '10px'); return; }
        state.analyser.getByteFrequencyData(dataArray);
        bars.forEach((b, i) => b.style.height = `${Math.max(10, (dataArray[i] || 0) / 255 * 60)}px`);
      }, 50);
    }

    function togglePauseResume() {
      if (state.isPaused) {
        state.mediaRecorder.resume();
        state.isPaused = false;
        state.pausedTime += Date.now() - state.pauseStartTime;
        elements.recordingDot.classList.remove('paused');
        elements.recordingStatusText.textContent = 'Recording';
        elements.pauseResumeBtn.classList.remove('resume');
        elements.pauseResumeBtn.classList.add('pause');
        elements.pauseIcon.style.display = 'block';
        elements.playIcon.style.display = 'none';
      } else {
        state.mediaRecorder.pause();
        state.isPaused = true;
        state.pauseStartTime = Date.now();
        elements.recordingDot.classList.add('paused');
        elements.recordingStatusText.textContent = 'Paused';
        elements.pauseResumeBtn.classList.remove('pause');
        elements.pauseResumeBtn.classList.add('resume');
        elements.pauseIcon.style.display = 'none';
        elements.playIcon.style.display = 'block';
      }
    }

    function showFinishConfirmation() {
      const total = Math.floor(state.elapsedTime / 1000);
      if (total < 900) {
        elements.modalTitle.textContent = 'Recording is Short';
        elements.modalMessage.textContent = `You've only recorded ${Math.floor(total / 60)} minutes. Are you sure the appointment is complete?`;
      } else {
        elements.modalTitle.textContent = 'Finish Recording?';
        elements.modalMessage.textContent = "Your recording will be processed and you'll receive the transcript via email within 15 minutes.";
      }
      elements.confirmModal.style.display = 'flex';
    }

    function hideConfirmModal() { elements.confirmModal.style.display = 'none'; }

    async function finishRecording() {
      if (state.wakeLock) { state.wakeLock.release(); state.wakeLock = null; }
      hideConfirmModal();
      clearInterval(state.timerInterval);
      clearInterval(state.waveformInterval);
      state.mediaRecorder.stop();
      await new Promise(r => state.mediaRecorder.onstop = r);
      state.mediaRecorder.stream.getTracks().forEach(t => t.stop());
      if (state.audioContext) state.audioContext.close();
      const audioBlob = new Blob(state.audioChunks, { type: 'audio/webm' });
      const payload = {
        agentName: state.user.name,
        clientName: state.clientName,
        appointmentType: state.appointmentType,
        date: new Date().toISOString().split('T')[0],
        notes: state.notes,
        userEmail: state.user.email,
        tcName: state.selectedTC.name,
        tcEmail: state.selectedTC.email
      };
      await uploadRecording(payload, audioBlob);
    }

    // Chunked Upload
    function updateProgress(pct, msg) {
      elements.progressBarFill.style.width = pct + '%';
      elements.progressText.textContent = msg || `${Math.round(pct)}%`;
    }

    async function uploadWithChunks(payload, audioBlob, progressCb) {
      const uploadId = `${Date.now()}-${Math.random().toString(36).substr(2,9)}`;
      const base64Audio = await blobToBase64(audioBlob);
      const base64Data = base64Audio.split(',')[1];
      const totalSize = base64Data.length;
      const totalChunks = Math.ceil(totalSize / CONFIG.chunkSize);
      console.log(`Chunked upload: ${totalChunks} chunks, ${(totalSize/1024/1024).toFixed(2)}MB`);

      for (let i = 0; i < totalChunks; i++) {
        const start = i * CONFIG.chunkSize;
        const chunkData = base64Data.slice(start, Math.min(start + CONFIG.chunkSize, totalSize));
        const chunkPayload = {
          action: 'uploadChunk', uploadId, chunkIndex: i, totalChunks, chunkData,
          ...(i === 0 ? { metadata: payload } : {})
        };
        let success = false, lastErr = null;
        for (let retry = 0; retry < CONFIG.maxRetries && !success; retry++) {
          try {
            const resp = await fetch(CONFIG.appsScriptUrl, { method: 'POST', headers: { 'Content-Type': 'text/plain' }, body: JSON.stringify(chunkPayload) });
            const result = await resp.json();
            if (result.success) {
              success = true;
              if (progressCb) progressCb(((i + 1) / totalChunks) * 100, `Uploading: ${i + 1}/${totalChunks}`);
              console.log(`Chunk ${i + 1}/${totalChunks} uploaded`);
            } else { lastErr = result.message; }
          } catch (e) { lastErr = e.message; }
          if (!success && retry < CONFIG.maxRetries - 1) await new Promise(r => setTimeout(r, 1000 * (retry + 1)));
        }
        if (!success) throw new Error(`Chunk ${i + 1} failed: ${lastErr}`);
      }

      if (progressCb) progressCb(100, 'Finalizing...');
      const finalResp = await fetch(CONFIG.appsScriptUrl, {
        method: 'POST', headers: { 'Content-Type': 'text/plain' },
        body: JSON.stringify({ action: 'finalizeUpload', uploadId, totalChunks, metadata: payload })
      });
      const finalResult = await finalResp.json();
      if (!finalResult.success) throw new Error(finalResult.message || 'Finalize failed');
      console.log('Upload complete!');
      return true;
    }

    async function uploadRecording(payload, audioBlob) {
      if (!navigator.onLine) { await saveOffline(payload, audioBlob); return; }
      elements.uploadingTitle.textContent = 'Uploading...';
      elements.uploadingMessage.textContent = 'Please wait while we upload your recording.';
      elements.uploadProgress.style.display = 'block';
      updateProgress(0, 'Preparing...');
      showScreen('uploading');
      try {
        await uploadWithChunks(payload, audioBlob, updateProgress);
        showScreen('success');
      } catch (err) {
        console.error('Upload failed:', err);
        await saveOffline(payload, audioBlob);
      }
    }

    async function saveOffline(payload, audioBlob) {
      try {
        elements.uploadingTitle.textContent = 'Saving locally...';
        elements.uploadingMessage.textContent = 'No connection. Saving to device.';
        elements.uploadProgress.style.display = 'none';
        showScreen('uploading');
        await saveToQueue(payload, audioBlob);
        await updateQueueBanner();
        setTimeout(() => showScreen('savedOffline'), 800);
      } catch (err) {
        console.error('Offline save failed:', err);
        alert('Error saving recording.');
        showScreen('setup');
      }
    }

    function blobToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    function resetForNewRecording() {
      state.clientName = '';
      state.appointmentType = '';
      state.selectedTC = null;
      state.notes = '';
      state.audioChunks = [];
      elements.clientName.value = '';
      elements.tcSelect.value = '';
      elements.notes.value = '';
      document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('selected'));
      elements.startRecordingBtn.disabled = true;
      showScreen('setup');
    }

    // Service Worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then(() => console.log('SW registered')).catch(e => console.log('SW skip:', e.message));
    }

    // Event Listeners
    elements.loginBtn.addEventListener('click', login);
    elements.loginPassword.addEventListener('keypress', e => { if (e.key === 'Enter') login(); });
    elements.loginEmail.addEventListener('keypress', e => { if (e.key === 'Enter') elements.loginPassword.focus(); });
    elements.logoutBtn.addEventListener('click', logout);
    document.querySelectorAll('.type-btn').forEach(b => b.addEventListener('click', () => selectAppointmentType(b.dataset.type)));
    elements.clientName.addEventListener('input', validateForm);
    elements.tcSelect.addEventListener('change', validateForm);
    elements.startRecordingBtn.addEventListener('click', startRecording);
    elements.pauseResumeBtn.addEventListener('click', togglePauseResume);
    elements.finishBtn.addEventListener('click', showFinishConfirmation);
    elements.modalCancel.addEventListener('click', hideConfirmModal);
    elements.modalConfirm.addEventListener('click', finishRecording);
    elements.newRecordingBtn.addEventListener('click', resetForNewRecording);
    elements.newRecordingOfflineBtn.addEventListener('click', resetForNewRecording);
    elements.queueRetryBtn.addEventListener('click', retryQueuedUploads);
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);

    // Init
    async function init() {
      await openDB();
      populateTCDropdown();
      checkStoredLogin();
      updateOnlineStatus();
      updateQueueBanner();
      if (navigator.storage && navigator.storage.persist) {
        const granted = await navigator.storage.persist();
        console.log('Persistent storage:', granted ? 'granted' : 'denied');
      }
    }
    init();
  </script>
</body>
</html>
